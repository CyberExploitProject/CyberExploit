#This program will instantiate a connection with a broker
#Link: https://www.youtube.com/watch?v=QAaXNt0oqSI

#Imports
import socket
from scapy.all import * #New client
from scapy.contrib import mqtt as MQTT

import time

#==============================================
def rewriteConfigFile(file_path, config):
    file = open(file_path,"w")
    for i in range(0, len(config)):
        file.write(config[i][0] + "=" + config[i][1])
    file.close()

#==============================================
def string2None(str):
    if str == 'None':
        return None
    else:
        return int(str)
def string2Byte(str):
    return str[2:len(str)-1].encode()
def string2tab(str):
    topics = str[1:-2].split(',')


#================================================
#================================================

#Socket creation
def create_socket(ip):
    s = socket.socket()
    print(ip)
    s.connect((ip, 1883))
    ss = StreamSocket(s, Raw)
    return ss


#Packet sending
def send_packet(ss, packet):
    if packet.type == 1:
        print('****', packet.protolevel)
        ss.sr1(packet)
    else:
        ss.send(packet)

#====================================

def send_scenarii(packets, ip):
    #Socket creation
    ss = create_socket(ip)

    #Senfind packet for each scenario
    for packet in packets:
        print('Send packet type: ', packet.type)
        if packet.type == 1:
            print('****', packet.protolevel)
            ss.sr1(packet)
        else:
            ss.send(packet)

    #Stopping connection
    ss.close()

#================================================
#================================================

def prepare_packet(scenarii):
    list_packets = []
    packets = scenarii.split('#PACKET#')
    for counter in range(len(packets)-1):
        flags = packets[counter].split(':')
        mqtt = MQTT.MQTT(type=string2None(flags[0]),
                         DUP=string2None(flags[1]),
                         QOS=string2None(flags[2]),
                         RETAIN=string2None(flags[3]),
                         len=string2None(flags[4]))
        if flags[0] == '1':
            mqtt_specific_fields =  MQTT.MQTTConnect(length=string2None(flags[5]),
                                                     protoname=string2Byte(flags[6]),
                                                     protolevel=string2None(flags[7]),
                                                     usernameflag=string2None(flags[8]),
                                                     passwordflag=string2None(flags[9]),
                                                     willretainflag=string2None(flags[10]),
                                                     willQOSflag=string2None(flags[11]),
                                                     willflag=string2None(flags[12]),
                                                     cleansess=string2None(flags[13]),
                                                     reserved=string2None(flags[14]),
                                                     klive=string2None(flags[15]),
                                                     clientIdlen=string2None(flags[16]),
                                                     clientId=string2Byte(flags[17]))
        elif flags[0] == '3':
            mqtt_specific_fields = MQTT.MQTTPublish(length=string2None(flags[5]),
                                                     topic=string2Byte(flags[6]),
                                                     msgid=string2None(flags[7]),
                                                     value=string2Byte(flags[8]))
        elif flags[0] == '8':
            mqtt_specific_fields = MQTT.MQTTSubscribe(msgid=string2None(flags[5]),
                                                      length=string2None(flags[6]),
                                                      topic=string2Byte(flags[7]),
                                                      QOS=string2None(flags[8]))
        elif flags[0] == '10':
            mqtt_specific_fields = MQTT.MQTTUnsubscribe(msgid=string2None(flags[5]),
                                                        topics=[string2tab(flags[6])])
        elif flags[0] == '2':
            mqtt_specific_fields = MQTT.MQTTConnack(sessPresentFlag=string2None(flags[5]),
                                                    retcode=string2None(flags[6]))
        elif flags[0] == '4':
            mqtt_specific_fields = MQTT.MQTTPuback(msgid=string2None(flags[5]))
        elif flags[0] == '5':
            mqtt_specific_fields = MQTT.MQTTPubrec(msgid=string2None(flags[5]))
        elif flags[0] == '6':
            mqtt_specific_fields = MQTT.MQTTPubrel(msgid=string2None(flags[5]))
        elif flags[0] == '7':
            mqtt_specific_fields = MQTT.MQTTPubcomp(msgid=string2None(flags[5]))
        elif flags[0] == '9':
            mqtt_specific_fields = MQTT.MQTTSuback(msgid=string2None(flags[5]),
                                                   retcode=string2None(flags[6]))
        elif flags[0] == '11':
            mqtt_specific_fields = MQTT.MQTTUnsuback(msgid=string2None(flags[5]))
        list_packets.append(mqtt/mqtt_specific_fields)
    return list_packets


#================================================================================================
#================================================================================================
#================================================================================================
#================================================================================================

#files names to read
file_ip_addresses = "ip-mac-addresses.txt"
file_scenarii = "payloads.txt"
file_config = "script.conf"


#Files reading
with open(file_ip_addresses) as file:
    ip_mac_addresses_tmp = file.readlines()

with open(file_scenarii) as file:
    scenarii_tmp = file.readlines()

with open(file_config) as file:
    config_tmp = file.readlines()

#==============================================

#Removing endline characters
ip_mac_addresses_tmp = [x.strip() for x in ip_mac_addresses_tmp]
scenarii = [x.strip() for x in scenarii_tmp]

#==============================================

#Creation of a two dimensions array : [ip, mac]
ip_mac_addresses = []
for line in ip_mac_addresses_tmp:
    ip_mac_addresses.append(line.split(" "))

#Creation of a two dimensions array for attack script
config = []
for line in config_tmp:
    config.append(line.split("="))

#===============================================

#Variable declarations from the configuration file for ease of understanding
start=config[0][1][:-1]
actualLoop=int(config[1][1][:-1])
nbLoops=int(config[2][1][:-1])
nbBrokers=int(config[3][1][:-1])
lastNbOfBrokersForLastLoop=int(config[4][1])


#==============================================
#==============================================


#Checking if the script has just been created
if start=="False":
    start = "True"

    #The configuration file is rewritten after modification
    config[0][1]=start+"\n"
    rewriteConfigFile(file_config, config)

    #End of process
    exit(0)


#Otherwise, beginning of the attacks
else:
    #checking loop number
    #If we're on the last lap AND we don't need to use all the brokers at our disposal
    if actualLoop==nbLoops and lastNbOfBrokersForLastLoop!=0:
        nbBrokersToAttack = lastNbOfBrokersForLastLoop
        maxCount = len(scenarii)
        validation=True

    #Otherwise, if we have not reached the final loop, we use the maximum number of brokers at our disposal
    elif actualLoop<=nbLoops:
        nbBrokersToAttack = nbBrokers
        maxCount = (actualLoop)*nbBrokersToAttack
        validation=True

    #Otherwise, we change the value of the Validation variable meaning there is no more sceanrio to send
    else:
        validation=False

    #==============================================

    #Safety not to perform additional loop laps
    if validation==True:

        #We create a list of available ports
        listPorts = []
        for i in range(0, nbBrokersToAttack):
            listPorts.append(50000 + i)


        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        #We retrieve the scenarios and format them properly
        preprared_scenarii = []
        for counter in range((actualLoop-1)*nbBrokers, maxCount):
            preprared_scenarii.append(prepare_packet(scenarii[counter]))



        #We instantiate a connection with each broker
        sockets_list = []
        for i in range(0, nbBrokersToAttack):
            sockets_list.append(create_socket(ip_mac_addresses[i][0]))

        time.sleep(3)

        #We get the maximum number of packets to send for the "longest" scenario
        maxNbOfPacketsObserved = 0
        for i in range(0, nbBrokersToAttack):
            if maxNbOfPacketsObserved < int(len(preprared_scenarii[i])):
                maxNbOfPacketsObserved = len(preprared_scenarii[i])
        print("Max number of packets observed =", maxNbOfPacketsObserved)



        #We're sending the script packages to the network
        for i in range(0, maxNbOfPacketsObserved):
            #For each socket
            for j in range(0, nbBrokersToAttack):
                #If the number of packets to send for this socket is smaller than the maximum number of packets for a scenario
                if len(preprared_scenarii[j]) <= maxNbOfPacketsObserved:
                    #Sending the packet
                    send_packet(sockets_list[j], preprared_scenarii[j][i])
            time.sleep(3)



        #Closing sockets
        for i in range(0, len(sockets_list)):
            sockets_list[i].close()


        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


        #Completion message
        time.sleep(10)
        print("Attacks are done !")

        #Updating config file
        actualLoop+=1
        config[1][1]=str(actualLoop)+"\n"
        rewriteConfigFile(file_config, config)
