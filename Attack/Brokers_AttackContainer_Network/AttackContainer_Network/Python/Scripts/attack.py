#Ce progamme va instancier une connexion avec un broker
#Lien: https://www.youtube.com/watch?v=QAaXNt0oqSI

#Imports
import socket
from scapy.all import * #Nouveau client
from scapy.contrib import mqtt as MQTT

import time

#==============================================
def rewriteConfigFile(file_path, config):
    file = open(file_path,"w")
    for i in range(0, len(config)):
        file.write(config[i][0] + "=" + config[i][1])
    file.close()

#==============================================
def string2None(str):
    if str == 'None':
        return None
    else:
        return int(str)
def string2Byte(str):
    return str[2:len(str)-1].encode()
def string2tab(str):
    topics = str[1:-2].split(',')
    
    
#================================================
#================================================

#Création de la socket
def create_socket(ip):
    s = socket.socket()
    s.connect((ip, 1883))
    ss = StreamSocket(s, Raw)
    return ss


#Envoie d'un packet
def send_packet(ss, packet):
    if packet.type == 1:
        print('****', packet.protolevel)
        ss.sr1(packet)
    else:
        ss.send(packet)
    #time.sleep(3)    

#====================================

def send_scenarii(packets, ip):
    #Création de la socket
    ss = create_socket(ip)
    #time.sleep(3)
    
    #Envoie des packets pour chaque scénario
    for packet in packets:
        print('Send packet type: ', packet.type)
        if packet.type == 1:
            print('****', packet.protolevel)
            ss.sr1(packet)
        else:
            ss.send(packet)
        #time.sleep(3)
        
    #On arrête la connexion
    ss.close()
    
#================================================
#================================================

def prepare_packet(scenarii):
    list_packets = []
    packets = scenarii.split('#PACKET#')
    for counter in range(len(packets)-1):
        flags = packets[counter].split(':')
        mqtt = MQTT.MQTT(type=string2None(flags[0]),
                         DUP=string2None(flags[1]),
                         QOS=string2None(flags[2]),
                         RETAIN=string2None(flags[3]),
                         len=string2None(flags[4]))
        if flags[0] == '1':
            mqtt_specific_fields =  MQTT.MQTTConnect(length=string2None(flags[5]),
                                                     protoname=string2Byte(flags[6]),
                                                     protolevel=string2None(flags[7]),
                                                     usernameflag=string2None(flags[8]),
                                                     passwordflag=string2None(flags[9]),
                                                     willretainflag=string2None(flags[10]),
                                                     willQOSflag=string2None(flags[11]),
                                                     willflag=string2None(flags[12]),
                                                     cleansess=string2None(flags[13]),
                                                     reserved=string2None(flags[14]),
                                                     klive=string2None(flags[15]),
                                                     clientIdlen=string2None(flags[16]),
                                                     clientId=string2Byte(flags[17]))
        elif flags[0] == '3':
            mqtt_specific_fields = MQTT.MQTTPublish(length=string2None(flags[5]),
                                                     topic=string2Byte(flags[6]),
                                                     msgid=string2None(flags[7]),
                                                     value=string2Byte(flags[8]))
        elif flags[0] == '8':
            mqtt_specific_fields = MQTT.MQTTSubscribe(msgid=string2None(flags[5]),
                                                      length=string2None(flags[6]),
                                                      topic=string2Byte(flags[7]),
                                                      QOS=string2None(flags[8]))
        elif flags[0] == '10':
            mqtt_specific_fields = MQTT.MQTTUnsubscribe(msgid=string2None(flags[5]),
                                                        topics=[string2tab(flags[6])])
        elif flags[0] == '2':
            mqtt_specific_fields = MQTT.MQTTConnack(sessPresentFlag=string2None(flags[5]),
                                                    retcode=string2None(flags[6]))
        elif flags[0] == '4':
            mqtt_specific_fields = MQTT.MQTTPuback(msgid=string2None(flags[5]))
        elif flags[0] == '5':
            mqtt_specific_fields = MQTT.MQTTPubrec(msgid=string2None(flags[5]))
        elif flags[0] == '6':
            mqtt_specific_fields = MQTT.MQTTPubrel(msgid=string2None(flags[5]))
        elif flags[0] == '7':
            mqtt_specific_fields = MQTT.MQTTPubcomp(msgid=string2None(flags[5]))
        elif flags[0] == '9':
            mqtt_specific_fields = MQTT.MQTTSuback(msgid=string2None(flags[5]),
                                                   retcode=string2None(flags[6]))
        elif flags[0] == '11':
            mqtt_specific_fields = MQTT.MQTTUnsuback(msgid=string2None(flags[5]))
        list_packets.append(mqtt/mqtt_specific_fields)
    return list_packets


#================================================================================================
#================================================================================================
#================================================================================================
#================================================================================================

#Nom des fichiers a lire
file_ip_addresses = "ip-mac-addresses.txt"
file_scenarii = "payloads.txt"
file_config = "script.conf"


#Lecture des fichiers
with open(file_ip_addresses) as file:
    ip_mac_addresses_tmp = file.readlines()

with open(file_scenarii) as file:
    scenarii_tmp = file.readlines()

with open(file_config) as file:
    config_tmp = file.readlines()

#==============================================

#Suppression des caracteres de fin de ligne
ip_mac_addresses_tmp = [x.strip() for x in ip_mac_addresses_tmp]
scenarii = [x.strip() for x in scenarii_tmp]

#==============================================

#Création d'un tableau à deux dimensions contenant les couples [ip, mac]
ip_mac_addresses = []
for line in ip_mac_addresses_tmp:
    ip_mac_addresses.append(line.split(" "))

#Création d'un tableau à deux dimensions contenant la configuration du script
config = []
for line in config_tmp:
    config.append(line.split("="))

#===============================================

#Déclarations de variables issues du fichier de configurations pour facilier la compréhension
start=config[0][1][:-1]
actualLoop=int(config[1][1][:-1])
nbLoops=int(config[2][1][:-1])
nbBrokers=int(config[3][1][:-1])
lastNbOfBrokersForLastLoop=int(config[4][1])


#==============================================
#==============================================


#On vérifie si le script vient de se créer
if start=="False":
    #On change sa valeur
    start = "True"

    #On réécrit le fichier de configuration après modification
    config[0][1]=start+"\n"
    rewriteConfigFile(file_config, config)

    #On termine le process
    exit(0)


#Si ce n'est pas le cas, on commence l'attaque
else:
    #On vérifie le tour de boucle
    #Si on est au dernier tour ET qu'on a pas besoin d'utiliser tous les brokers à notre disposition
    if actualLoop==nbLoops and lastNbOfBrokersForLastLoop!=0:
        nbBrokersToAttack = lastNbOfBrokersForLastLoop
        maxCount = len(scenarii)
        validation=True

    #Sinon si on a pas atteint la boucle finale, on utilise le maximum de brokers à notre disposition
    elif actualLoop<=nbLoops:
        nbBrokersToAttack = nbBrokers
        maxCount = (actualLoop)*nbBrokersToAttack
        validation=True

    #Sinon, on utilise le maximum de brokers à notre disposition
    else:
        print("All attacks were done.")
        validation=False

    #==============================================

    #Sécurité pour ne pas effectuer des tours de boucle supplémentaires
    if validation==True:

        #On crée une liste de ports disponibles
        listPorts = []
        for i in range(0, nbBrokersToAttack):
            listPorts.append(50000 + i)


        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        #On récupère les scénarii et on les formate correctement
        preprared_scenarii = []
        for counter in range((actualLoop-1)*nbBrokers, maxCount):
            preprared_scenarii.append(prepare_packet(scenarii[counter]))
            
        
        
        #On instancie une connexion avec chaque broker
        sockets_list = []
        for i in range(0, nbBrokersToAttack):
            sockets_list.append(create_socket(ip_mac_addresses[i][0]))
          
        time.sleep(3)
         
        #On récupère le nombre de max de packets à envoyer pour le plus "long" scenario
        maxNbOfPacketsObserved = 0
        for i in range(0, nbBrokersToAttack):
            if maxNbOfPacketsObserved < int(len(preprared_scenarii[i])):
                maxNbOfPacketsObserved = len(preprared_scenarii[i])
        print("Max number of packets observed =", maxNbOfPacketsObserved)    
            
            
            
        #On envoie les packets des scenarii à la chaine
        for i in range(0, maxNbOfPacketsObserved):
            #Pour chaque socket maintenant
            for j in range(0, nbBrokersToAttack):
                #Si le nombre de packets à envoyer pour cette socket est plus petit que le nb max de packets pour un scénario
                if len(preprared_scenarii[j]) <= maxNbOfPacketsObserved:
                    #On envoie le packet
                    send_packet(sockets_list[j], preprared_scenarii[j][i])
            time.sleep(3)
        
        
        
        #On ferme les sockets
        for i in range(0, len(sockets_list)):
            sockets_list[i].close()
        
        """
        index = 0
        sockets_list = []
        for counter in range((actualLoop-1)*nbBrokers, maxCount):
            
            
            
            #On incrémente indexPort
            index += 1
        """    

        """
        #BOUCLE IMPORTANTE - UNE ATTAQUE DOIT SE FAIRE DANS CETTE BOUCLE
        # counter correspond à l'index du scenario dans le tableau "scenarii"
        index = 0
        for counter in range((actualLoop-1)*nbBrokers, maxCount):
            
            #On récupère le scénario
            packets = prepare_packet(scenarii[counter])
            
            #On envoie le scénario au broker
            send_scenarii(packets, ip_mac_addresses[index][0])
            
            time.sleep(10)
            
            #On incrémente indexPort
            index += 1
        """
        
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        

        #On affiche un message de fin
        time.sleep(10)
        print("Attacks are done !")
        
        #On met à jour le fichier de configuration
        actualLoop+=1
        config[1][1]=str(actualLoop)+"\n"
        #rewriteConfigFile(file_config, config)
